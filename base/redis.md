# Redis

### 特性：

1. 速度快

- 所有的数据是存放在内存中的，是redis速度快的主要原因
- 采用C语言实现，执行速度相对更快
- 使用单线程架构，预防了多线程可能产生竞争的问题
- 作者对于Redis源码精细打磨

2. 基于键值对的数据结构服务器

   Redis的值不仅可以是字符串，还可以是具体的数据结构。它主要提供了5中数据结构：string、hash、list、set、sort set，同时在字符串的基础之上演变出了位图（Bitmaps）和HyperLogLog两种数据结构，并随着LBS（Location Based Service）的不断发展，Redis 3.2版本中加入有关GEO（地理信息定位）的功能。

3. 丰富的功能

   除了5中数据结构，Redis还提供了许多额外的功能：

   - 提供了键过期功能，可以用来实现环迅。
   - 提供了发布订阅功能。可以用来实现消息系统。
   - 支持Lua脚本功能，可以利用Lua创造出新的Redis指令。
   - 提供了简单的事物功能，能在一定程度上保证事物特性。
   - 提供了流水线（Pipeline）功能，这样客户端能将一批命令一次性传递到Redis，减少网络开销

4. 简单稳定

   - 源码很少，早期版本的代码只有2万行左右，3.0版本后由于添加了集群特性，代码增至5万行左右，相对于很多NoSql数据来说，代码量相对要少很多。
   - 使用单线程模型，这样不仅使得Redis服务端处理模型变得简单，而且也使得客户端开发变得简单。
   - Redis不需要依赖于操作系统中的类库（例如Memcache需要依赖linevent这样的系统类库），自己实现了事件处理的相关功能。

5. 客户端语言多

   Redis提供了简单的TCP通信协议，很多变成语言都可以很方便的接入到Redis，几乎涵盖了主流的变成语言。

6. 持久化

   Redis提供了两种持久化方式：RDB和AOF，既可以用两种策略将内存的数据保存到硬盘中，这样就保证了数据的可持久性。

7. 主从复制

   Redis提供了主从复制功能，实现了多个相同数据的Redis数据副本，复制功能是分布式Redis的基础。

8. 高可用和分布式

   Redis从2.8版本正式提供了高可用实现Redis Sentinel，它能够保证Redis节点的故障发现和故障自动转移。从3.0版本正式提供了分布式实现Redis Cluster，它是真正的分布式实现，提供了高可用、读写和容量的扩展性。

### 使用场景

1. 缓存

   Redis提供了键值过期时间设置，并且也提供了灵活控制最大内存和内存溢出后的淘汰策略。

2. 排行榜系统

   Redis提供了列表和有序集合数据结构，合理的使用这些数据结构可以很方便的构建各种排行榜系统。

3. 计数器应用

   例如视频网站有播放数，电商网站有浏览数，为了保持数据的实时性，每一次播放课浏览都要做加1的操作，如果并发量很大，对于传统数据库是一个挑战。Redis天然支持计数功能切计数的性能非常好，可以说是计数器系统的重要选择。

4. 社交网络

   踩/赞、粉丝、共同好友/喜好、推动、下拉刷新等社交网站的必备功能，由于社交网站访问量通常比较大，而且传统的关系型输数据不太社和保存这种类型的数据，Redis 提供的数据结构可以相对比较容易地实现这些功能。

5. 消息队列系统

   消息队列系统可以说是一个大型网站的必备基础组件，因为其具有业务解耦，非实时业务削峰等特性。Redis提供了发布订阅功能个阻塞队列的可能，虽然和专业的消息队列比还不够强大，但是对于一般的消息队列功能基本可以满足。

### Redis不可以做什么

​       在数据规模和数据冷热的角度来进行分析。站在数据规模的角度看，数据可以分为大规模数据和小规模数据，我们知道Redis的数据 是存放在内存中的，如果数据量太大的话经济成太高。

​       站在数据冷热的角度看，数分为热数据和冷数据，热数据通常是指需要频繁操作的数据，反之为冷数据，例如对视频网站来说，视频基本信息基本上在各个业务线都是经常要操作的数据属于热数据，而客户观看记录不一定是经常需要访问的数据冷数据。如果将冷数据放在内存中，基本上是对于内存的浪费，但对于一些热数据来说，可以放Redis中加速读写，也可以减轻后端存储的负载。

数据结构类型：

1. String
2. Hash
3. List
4. Set
5. Sort Set
6. Bitmaps
7. HyperLogLogs

## 使用Redis作为LRU缓存 

当Redis用作缓存时，通常可以让它在添加新数据时自动逐出旧数据。这种行为在开发人员社区中非常有名，因为它是流行的*memcached*系统的默认行为 。

LRU实际上只是支持的驱逐方法之一。此页面介绍了Redis `maxmemory`指令的更一般主题，该指令用于将内存使用限制为固定量，并且它还深入介绍了Redis使用的LRU算法，实际上是精确LRU的近似值。

从Redis 4.0版开始，引入了新的LFU（最不常用）驱逐策略。本文档的单独部分对此进行了介绍。



### Maxmemory配置指令

所述`maxmemory`配置指令，以便用于Redis的配置为使用的存储器的指定量的数据集。可以使用该`redis.conf`文件设置配置指令，或稍后在运行时使用[CONFIG SET](https://redis.io/commands/config-set)命令。

例如，为了配置100兆字节的内存限制，可以在`redis.conf`文件中使用以下指令。

```
maxmemory 100mb
```

设置`maxmemory`为零会导致无内存限制。这是64位系统的默认行为，而32位系统使用3GB的隐式内存限制。

达到指定的内存量时，可以在不同的行为中进行选择，称为**策略**。Redis可以只返回可能导致使用更多内存的命令的错误，或者它可以逐出旧数据以便每次添加新数据时返回到指定的限制。

### 驱逐政策

`maxmemory`使用`maxmemory-policy`配置指令配置达到限制时Redis遵循的确切行为。

可以使用以下政策：

1. **noeviction**：当达到内存限制并且客户端尝试执行可能导致使用更多内存的命令时返回错误（大多数写命令，但[DEL](https://redis.io/commands/del)和一些例外）。
2. **allkeys-lru**：首先尝试删除最近使用较少的（LRU）密钥来逐出密钥，以便为添加的新数据腾出空间。
3. **volatile-lru**：首先尝试删除最近使用较少的（LRU）密钥，但仅在具有**过期设置的**密钥中删除密钥，以便为添加的新数据腾出空间。
4. **allkeys-random**：**随机**逐出密钥，以便为添加的新数据腾出空间。
5. **volatile-random**：**随机**逐出密钥以便为添加的新数据腾出空间，但只驱逐带有**过期集的**密钥。
6. **volatile-ttl**：用**过期集**驱逐密钥，并尝试先用较短的生存时间（TTL）驱逐密钥，以便为添加的新数据腾出空间。

如果没有用于驱逐匹配先决条件的keys，则volatile-lru，volatile-random和volatile-ttl策略的行为类似于noeviction。

### 新的LFU模式

从Redis 4.0开始，可以使用新的[最少使用的逐出模式](http://antirez.com/news/109)。在某些情况下，此模式可能更好（提供更好的命中/未命中率），因为使用LFU Redis将尝试跟踪项目的访问频率，以便很少使用的项目被驱逐，而使用的项目通常具有更高的机会留在记忆中

如果您在LRU中考虑，最近访问但实际上几乎从未请求的项目将不会过期，因此风险是驱逐将来有更高机会被请求的密钥。LFU没有这个问题，并且通常应该更好地适应不同的访问模式。

要配置LFU模式，可以使用以下策略：

7. `volatile-lfu` 使用过期集在密钥中使用近似LFU进行驱逐。
8. `allkeys-lfu` 使用近似LFU逐出任何键。

## 持久化

Redis 支持RDB 和 AOF 两种持久化机制，持久化功能有效地避免因进程退出造成的数据丢失的问题，当下次重启时，利用之前持久化的文件即可实现数据恢复。

### RDB

RBD 持久化是把当前进程数据生成快照保存到硬盘的过程，出发RDB 持久化分为手动触发和自动触发。

#### 触发机制

手动触发分别对应 save 和 bgsave 命令：

* save 命令：阻塞当前redis 服务器，知道 RDB 过程完成为止，对于内存比较大的实例会造成长时间阻塞，线上环境不建议使用。运行save 命令对应的 Redis 日志如下：

  * DB save on disk

* bgsave 命令：Redis 进程执行fork 操作创建子进程，RDB 持久化由子进程负责，完成后自动结束。阻塞只发生在fork 阶段，一般时间很短。运行 bgsave 命令对应的Redis 日志如下：

  * Background saving statred by pid 3151
  * DB saved on disk
  * RDB : 0 MB of memory used by copy-on-writs
  * Background saving terminated with success

  显然 bgsave 命令是针对 save 阻塞问题做的优化。因此Redis 内部所有的设计 RDB 的操作都采用了 bgsave 方式，而save 命令已经废弃。

除了执行命令手动触发之外，Redis 内部还存在自动触发 RDB 的持久化机制，例如一下场景：

1. 使用 save 相关配置，如 `save m n `。表示 m 秒内数据存在 n 次修改时，自动触发 save.。
2. 如果节点执行全量复制操作，主节点自动执行 bgsave 生成 RDB 文件并发送给从节点。
3. 执行 debug reload 命令重新加载redis 时，也会自动触发 save 操作。
4. 默认情况下执行shutdown 命令时，如果没有开启 AOF 持久化功能则自动执行 bgsave。

#### 流程

1. 执行 bgsave 命令，Redis 父进程判断当前是否存在执行的子进程，如RDB/AOF 子进程，如果存在则 bgsave 命令直接返回。
2. 父进程执行 fork 操作创建子进程，fork 操作过程中父进程会阻塞，通过 info stats 命令查看 latest_fork_usec 选项，可以获取最近一个fork 操作的耗时，单位为微妙。
3. 父进程 fork 完成后，bgsave 命令返回 `Background saving statred`信息并不再阻塞父进程，可以继续响应其他命令。
4. 子进程创建 RDB 问价，根据父进程内存生成临时快照文件，完成后对原有文件进行原子替换。执行 lastsave 命令可以获取最后一次生成 RDB 的时间，对应 info 统计的 rdb_last_save_time 选项。
5. 进程发送信号给父进程表示完成，父进程跟新统计信息，具体见 info Persistence 下的 rdb_*  相关选项。

#### RDB文件的处理

**保存**： RBD 文件保存在 dir 配置指定的目录下，文件名通过 dbfilename 配置指定。可以通过执行 `config set dir {newdir}` 和 `config set dbfilename {newFileName}`运行期动态执行，当下次运行时 RDB 文件会保存到新目录。

**压缩**：Redis 默认采用 LZF 算法对生成的 RBD 文件做压缩处理，压缩后的文件远远小于内存大下，默认开启，可以通过参数`config set rfbcompression {yes|no}` 动态修改。

**校验**：如果 Redis 加载损坏的 RDB 文件时拒绝启动，并打印如下日志：

> Short read or OOM loading DB.Unrecoverable error,aborting now.

这时可以使用 Redis 提供的redis-check-dump 工具检测 RDB 文件并获取对应的错误报告。

### RDB 的优缺点

RDB 的优点：

* RDB 是一个紧凑压缩的二进制文件，代表 Redis 在某个时间点上的数据快照。非常使用与备份，全量复制等场景。比如每 6 小时执行 bgsave 备份，并把 RDB 文件拷贝带远程机器或者文件系统中（如hdfs）,用于灾难恢复。
* Redis 加载恢复数据远远快于 AOF 的方式。

RDB 的缺点：

* RDB 方式数据没办法做到实时持久化。因为 bgsave 每次运行都要执行 fork 操作创建子进程，属于重量级操作，频繁执行成本过高。
* RDB 文件使用特定二进制格式保存，Redis 版本演进过程中有多个格式的 RDB 版本，存在老版本 Redis 服务无法兼容新版 RDB格式的问题。

针对 RDB 不适合实时持久化的问题，Redis 提供了 AOF 持久化方式来解决。





## 缓存击穿问题

缓存击穿表示恶意用户模拟请求很多缓存中不存在的数据，由于缓存中都没有，导致这些请求短时间内直接落在了数据库上，导致数据库崩溃。

### 解决方案

- 布隆过滤器（推荐）

  > 布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的[二进制](https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6/361457)向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都比一般的算法要好的多，缺点是有一定的误识别率和删除困难。

- 将查询缓存

  > 不管数据库中是否有数据，都在缓存中保存对应的key，值为空就行。–这样是为了避免数据库中没有这个数据，导致的平凡穿透缓存对数据库进行访问。

- 使用互斥锁排队

  > 业界比价普遍的一种做法，即根据key获取value值为空时，锁上，从数据库中load数据后再释放锁。若其它线程获取锁失败，则等待一段时间后重试。这里要注意，分布式环境中要使用分布式锁，单机的话用普通的锁（synchronized、Lock）就够了。



## 缓存雪崩问题

缓存在同一时间内大量键过期（失效），接着来的一大波请求瞬间都落在了数据库中导致连接异常。

### 解决方案 ###

- 也是像解决缓存穿透一样加锁排队，实现同上;

- 建立备份缓存，缓存A和缓存B，A设置超时时间，B不设值超时时间，先从A读缓存，A没有再读B，并且更新A缓存和B缓存;

- 设置缓存超时时间的时候加上一个随机的时间长度，比如这个缓存key的超时时间是固定的5分钟加上随机的2分钟，这样可从一定程度上避免雪崩问题；

## 缓存预热

缓存预热就是系统上线后，提前将相关的缓存数据直接加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！

 缓存预热解决方案：

- 直接写个缓存刷新页面，上线时手工操作下
- 数据量不大，可以在项目启动的时候自动进行加载
- 定时刷新缓存

