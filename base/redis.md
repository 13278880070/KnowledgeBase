# Redis

### 特性：

1. 速度快

- 所有的数据是存放在内存中的，是redis速度快的主要原因
- 采用C语言实现，执行速度相对更快
- 使用单线程架构，预防了多线程可能产生竞争的问题
- 作者对于Redis源码精细打磨

2. 基于键值对的数据结构服务器

   Redis的值不仅可以是字符串，还可以是具体的数据结构。它主要提供了5中数据结构：字符串、哈希、列表、集合、有序集合，同时在字符串的基础之上演变出了位图（Bitmaps）和HyperLogLog两种数据结构，并随着LBS（Location Based Service）的不断发展，Redis 3.2版本中加入有关GEO（地理信息定位）的功能。

3. 丰富的功能

   除了5中数据结构，Redis还提供了许多额外的功能：

   - 提供了键过期功能，可以用来实现环迅。
   - 提供了发布订阅功能。可以用来实现消息系统。
   - 支持Lua脚本功能，可以利用Lua创造出新的Redis指令。
   - 提供了简单的事物功能，能在一定程度上保证事物特性。
   - 提供了流水线（Pipeline）功能，这样客户端能将一批命令一次性传递到Redis，减少网络开销

4. 简单稳定

   - 源码很少，早期版本的代码只有2万行左右，3.0版本后由于添加了集群特性，代码增至5万行左右，相对于很多NoSql数据来说，代码量相对要少很多。
   - 使用单线程模型，这样不仅使得Redis服务端处理模型变得简单，而且也使得客户端开发变得简单。
   - Redis不需要依赖于操作系统中的类库（例如Memcache需要依赖linevent这样的系统类库），自己实现了事件处理的相关功能。

5. 客户端语言多

   Redis提供了简单的TCP通信协议，很多变成语言都可以很方便的接入到Redis，几乎涵盖了主流的变成语言。

6. 持久化

   Redis提供了两种持久化方式：RDB和AOF，既可以用两种策略将内存的数据保存到硬盘中，这样就保证了数据的可持久性。

7. 主从复制

   Redis提供了主从复制功能，实现了多个相同数据的Redis数据副本，赋值功能是分布式Redis的基础。

8. 高可用和分布式

   Redis从2.8版本正式提供了高可用实现Redis Sentinel，它能够保证Redis节点的故障发现和故障自动转移。从3.0版本正式提供了分布式实现Redis Cluster，它是真正的分布式实现，提供了高可用、读写和容量的扩展性。

### 使用场景

1. 缓存

   Redis提供了键值过期时间设置，并且也提供了灵活控制最大内存和内存溢出后的淘汰策略。

2. 排行榜系统

   Redis提供了列表和有序集合数据结构，合理的使用这些数据结构可以很方便的构建各种排行榜系统。

3. 计数器应用

   例如视频网站有播放数，电商网站有浏览数，为了保持数据的实时性，每一次播放课浏览都要做加1的操作，如果并发量很大，对于传统数据库是一个挑战。Redis天然支持计数功能切计数的性能非常好，可以说是计数器系统的重要选择。

4. 社交网络

   踩/赞、粉丝、共同好友/喜好、推动、下拉刷新等社交网站的必备功能，由于社交网站访问量通常比较大，而且传统的关系型输数据不太社和保存这种类型的数据，Redis 提供的数据结构可以相对比较容易地实现这些功能。

5. 消息队列系统

   消息队列系统可以说是一个大型网站的必备基础组件，因为其具有业务解耦，非实时业务削峰等特性。Redis提供了发布订阅功能个阻塞队列的可能，虽然和专业的消息队列比还不够强大，但是对于一般的消息队列功能基本可以满足。

### Redis不可以做什么

​       在数据规模和数据冷热的角度来进行分析。站在数据规模的角度看，数据可以分为大规模数据和小规模数据，我们知道Redis的数据 是存放在内存中的，如果数据量太大的话经济成太高。

​       站在数据冷热的角度看，数分为热数据和冷数据，热数据通常是指需要频繁操作的数据，反之为冷数据，例如对视频网站来说，视频基本信息基本上在各个业务线都是经常要操作的数据属于热数据，而客户观看记录不一定是经常需要访问的数据冷数据。如果将冷数据放在内存中，基本上是对于内存的浪费，但对于一些热数据来说，可以放Redis中加速读写，也可以减轻后端存储的负载。







数据结构类型：

1. String
2. Hash
3. List
4. Set
5. Sort Set
6. Bitmaps
7. HyperLogLogs

## 使用Redis作为LRU缓存 

当Redis用作缓存时，通常可以让它在添加新数据时自动逐出旧数据。这种行为在开发人员社区中非常有名，因为它是流行的*memcached*系统的默认行为 。

LRU实际上只是支持的驱逐方法之一。此页面介绍了Redis `maxmemory`指令的更一般主题，该指令用于将内存使用限制为固定量，并且它还深入介绍了Redis使用的LRU算法，实际上是精确LRU的近似值。

从Redis 4.0版开始，引入了新的LFU（最不常用）驱逐策略。本文档的单独部分对此进行了介绍。



### Maxmemory配置指令

所述`maxmemory`配置指令，以便用于Redis的配置为使用的存储器的指定量的数据集。可以使用该`redis.conf`文件设置配置指令，或稍后在运行时使用[CONFIG SET](https://redis.io/commands/config-set)命令。

例如，为了配置100兆字节的内存限制，可以在`redis.conf`文件中使用以下指令。

```
maxmemory 100mb
```

设置`maxmemory`为零会导致无内存限制。这是64位系统的默认行为，而32位系统使用3GB的隐式内存限制。

达到指定的内存量时，可以在不同的行为中进行选择，称为**策略**。Redis可以只返回可能导致使用更多内存的命令的错误，或者它可以逐出旧数据以便每次添加新数据时返回到指定的限制。

### 驱逐政策

`maxmemory`使用`maxmemory-policy`配置指令配置达到限制时Redis遵循的确切行为。

可以使用以下政策：

1. **noeviction**：当达到内存限制并且客户端尝试执行可能导致使用更多内存的命令时返回错误（大多数写命令，但[DEL](https://redis.io/commands/del)和一些例外）。
2. **allkeys-lru**：首先尝试删除最近使用较少的（LRU）密钥来逐出密钥，以便为添加的新数据腾出空间。
3. **volatile-lru**：首先尝试删除最近使用较少的（LRU）密钥，但仅在具有**过期设置的**密钥中删除密钥，以便为添加的新数据腾出空间。
4. **allkeys-random**：**随机**逐出密钥，以便为添加的新数据腾出空间。
5. **volatile-random**：**随机**逐出密钥以便为添加的新数据腾出空间，但只驱逐带有**过期集的**密钥。
6. **volatile-ttl**：用**过期集**驱逐密钥，并尝试先用较短的生存时间（TTL）驱逐密钥，以便为添加的新数据腾出空间。

如果没有用于驱逐匹配先决条件的keys，则volatile-lru，volatile-random和volatile-ttl策略的行为类似于noeviction。

### 新的LFU模式

从Redis 4.0开始，可以使用新的[最少使用的逐出模式](http://antirez.com/news/109)。在某些情况下，此模式可能更好（提供更好的命中/未命中率），因为使用LFU Redis将尝试跟踪项目的访问频率，以便很少使用的项目被驱逐，而使用的项目通常具有更高的机会留在记忆中

如果您在LRU中考虑，最近访问但实际上几乎从未请求的项目将不会过期，因此风险是驱逐将来有更高机会被请求的密钥。LFU没有这个问题，并且通常应该更好地适应不同的访问模式。

要配置LFU模式，可以使用以下策略：

7. `volatile-lfu` 使用过期集在密钥中使用近似LFU进行驱逐。

8. `allkeys-lfu` 使用近似LFU逐出任何键。

## 缓存击穿问题

缓存击穿表示恶意用户模拟请求很多缓存中不存在的数据，由于缓存中都没有，导致这些请求短时间内直接落在了数据库上，导致数据库崩溃。

### 解决方案

- 布隆过滤器（推荐）

  > 布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的[二进制](https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6/361457)向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都比一般的算法要好的多，缺点是有一定的误识别率和删除困难。

- 将查询缓存

  > 不管数据库中是否有数据，都在缓存中保存对应的key，值为空就行。–这样是为了避免数据库中没有这个数据，导致的平凡穿透缓存对数据库进行访问。

- 使用互斥锁排队

  > 业界比价普遍的一种做法，即根据key获取value值为空时，锁上，从数据库中load数据后再释放锁。若其它线程获取锁失败，则等待一段时间后重试。这里要注意，分布式环境中要使用分布式锁，单机的话用普通的锁（synchronized、Lock）就够了。



## 缓存雪崩问题

缓存在同一时间内大量键过期（失效），接着来的一大波请求瞬间都落在了数据库中导致连接异常。

### 解决方案 ###

- 也是像解决缓存穿透一样加锁排队，实现同上;

- 建立备份缓存，缓存A和缓存B，A设置超时时间，B不设值超时时间，先从A读缓存，A没有再读B，并且更新A缓存和B缓存;

- 设置缓存超时时间的时候加上一个随机的时间长度，比如这个缓存key的超时时间是固定的5分钟加上随机的2分钟，酱紫可从一定程度上避免雪崩问题；

## 缓存预热

 缓存预热就是系统上线后，提前将相关的缓存数据直接加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！

 缓存预热解决方案：

- 直接写个缓存刷新页面，上线时手工操作下
- 数据量不大，可以在项目启动的时候自动进行加载
- 定时刷新缓存

