1. 下列选项中，不可能是快速排序第2趟排序结果的是 （）

   A `4 14 10 12 8 6 18`

   B `4 6 10 8 12 14 18`

   C `6 4 10 8 14 12 18`

   只需要掌握一点就可以解出这个问题：

   每趟排序就有一个元素排在了最终的位置上。那么就是说，第n趟结束，**至少**有n个元素已经排在了最终的位置上。

   所以我们把最终排序结果写出来：然后计算在最终位置上的个数就可以

2. 若一颗二叉树的前序遍历为a,b,c,d,e,后序遍历为c,e,d,b,a，则根节点的孩子节点是？

   解：只有中序遍历和前、后 之一的遍历才能唯一的确定一棵树。所以只有前后的是时候，树的状态可能有几种情况。

   这个问题需要联想到树的前后序遍历的迭代算法

   ```python
   def preOrder(root):
   	stack = [root]
   	res = []
   	while stack:
   		t = stack.pop()
   		res.append(t.val)
   		if t.right:
   			stack.append(t.right)
   		if t.left:
   			stack.append(t.left)
   	return res
   	
   ```

   前序遍历按照根左右的顺序遍历

   ```python
   def postOrder(root):
   	stack = [root]
   	res = []
   	while stack:
   		t = stack.pop()
   		res.append(t.val)
   		if t.right:
   			stack.append(t.left)
   		if t.left:
   			stack.append(t.right)
   	return res[::-1]
   ```

   后续迭代遍历的方法其实就是前序遍历的相反操作。

   接下来可以画一个满二叉树，你会发现规律，前序遍历中，每个父节点都与他的左子树相邻在右侧相邻，后续遍历中，每个父节点都与他的右子树左侧相邻。

   那么接下看 两组遍历顺序：

   pre：a b c d e

   post: c d e b a

   通过随意一个前后序遍历可知，根节点为 a。

   pre 中 a 与b 右相邻，post 中与a 做左相邻的还是 b，在前后续遍历中，左右子节点先遍历。但是前后遍历a的子节点一样。这就说明，a只有一个孩子。但是不能说明它在哪一侧。

   然后观察 b，pre 中 b 与c 右相邻，post 中 b 与 e 做相邻，说明 c 与 e 可能为 b 孩子节点，或者孙子等等。

   再观察 c ,pre 中与 d 右相邻，post 中它在最左边，由于后续遍历的性质，知道c 一定没有子树了。它是叶子节点。

   因为a 只有一个孩子 b，c 是叶子节点。这样剩下的 d 和 e，一定在b 的一侧了。因为 e 在 pre 的最右边，e 也是叶子节点。

   最后剩下一个 b，b 在 pre 和 post 中的右左相邻，都是 c，那么 b 一定是c 的父节点。

   可以按照这个规则画出好几个符合规则的子树。

    

3. 1024! 末尾有多少个0?

   末尾0的个数取决于乘法中因子2和5的个数。显然乘法中因子2的个数大于5的个数，所以我们只需统计因子5的个数。 
   是5的倍数的数有： 1024 / 5 = 204个 
   是25的倍数的数有：1024 / 25 = 40个 
   是125的倍数的数有：1024 / 125 = 8个 
   是625的倍数的数有：1024 / 625 = 1个 
   所以1024! 中总共有204+40+8+1=253个因子5。 
   也就是说1024! 末尾有253个0。

4. 一个二叉树有100个子节点数为2的节点，100个子节点数为1的节点，那么个子节点数为0的节点（叶节点）的个数为：

   度数(边数) = 所有节点数-1：

   这里度数=2*100+100=300，节点数：100+100+叶子节点数

   所以叶子节点数=101

​	

