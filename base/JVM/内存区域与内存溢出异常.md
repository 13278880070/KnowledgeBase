## 自动内存管理机制

运行时数据区：Java虚拟机定义了在程序执行期间使用的各种运行时数据区域。 其中一些数据区域是在Java虚拟机启动时创建的，仅在Java虚拟机退出时销毁。 其他数据区域是每个线程所占的空间。 线程数据区域是随着线程销毁和创建的。

**PC 寄存器（程序计数器）**：Java虚拟机可以同时支持许多执行线程。 每个Java虚拟机线程都有自己的pc（程序计数器）寄存器。 在任何时候，每个Java虚拟机线程都在执行单个方法的代码，即该线程的当前方法（第2.6节）。 如果该方法不是native方法，则pc寄存器包含当前正在执行的Java虚拟机指令的地址。 如果线程当前正在执行的方法是native的，则Java虚拟机的pc寄存器的值是未定义的。 Java虚拟机的pc寄存器足够宽，可以在特定平台上保存returnAddress或native 指针。

 **java虚拟机栈**：每个Java虚拟机线程都有一个私有Java虚拟机栈，与线程同时创建。 Java虚拟机栈存储帧。 Java虚拟机栈类似于传统语言的栈，例如C：它保**存局部变量和部分结果，并在方法调用和返回中起作用**。 由于除了压入和弹出帧之外，永远不会直接操作Java虚拟机栈，而帧可以是堆分配的。所以 Java虚拟机栈的内存不需要是连续的。

在Java®虚拟机规范的第一版中，Java虚拟机栈被和Java栈是一个意思。

此规范允许Java虚拟机栈具有固定大小或根据计算的需要动态扩展和收缩。 如果Java虚拟机堆栈具有固定大小，则可以在创建该栈时独立选择每个Java虚拟机堆栈的大小。

Java虚拟机实现可以为程序员或用户提供对Java虚拟机栈的初始大小的控制，以及在动态扩展或收缩Java虚拟机堆栈的情况下，控制最大和最小大小。

以下异常条件与Java虚拟机堆栈相关联：

- 如果线程中的计算需要比允许的更大的Java虚拟机堆栈，则Java虚拟机会抛出`StackOverflowError`.
- 如果可以动态扩展Java虚拟机堆栈，并且尝试进行扩展但可以使用的内存不足以实现扩展，或者可以使用的内存不足以为新线程创建初始Java虚拟机堆栈，则可以使用Java虚拟机抛出`OutOfMemoryError`.

**堆**：Java虚拟机有一个在所有Java虚拟机线程之间共享的堆。堆是运行时数据区，**从中分配所有类实例和数组的内存**。

堆是在虚拟机启动时创建的。存储在堆上的对象由自动存储管理系统（称为垃圾收集器）回收 ; 对象永远不会被用户显式释放。 Java虚拟机假设没有特定类型的自动存储管理系统，可以根据实现者的系统要求选择存储管理技术。堆可以是固定大小的，或者可以根据计算的需要进行扩展，如果不需要更大的堆，则可以收缩。**堆的内存不需要是连续的。**

Java虚拟机实现可以为程序员或用户提供对堆的初始大小的控制，以及如果可以动态扩展或收缩堆，则控制最大和最小堆大小。

以下异常情况与堆相关联：

- 如果计算需要的堆的大小超过自动存储管理系统可用的堆，则Java虚拟机会抛出`OutOfMemoryError`。

**方法区**：Java虚拟机具有在所有Java虚拟机线程之间共享的方法区域。 方法区域类似于传统语言的编译代码的存储区域或类似于操作系统进程中的“文本”段。 它存储每个类的结构，例如**运行时常量池，字段和方法数据，以及方法和构造函数的代码，包括类和接口初始化以及实例初始化中使用的特殊方法**

方法区域是在虚拟机启动时创建的。 虽然方法区域在逻辑上是堆的一部分，但是简单的虚拟机实现可能选择不进行垃圾收集或压缩它。 此规范不强制方法区域的位置或用于管理编译代码的策略。 方法区域可以是固定大小的，或者可以根据计算的需要进行扩展，并且如果不需要更大的方法区域，则可以缩小方法区域。 方法区域的内存不需要是连续的。

Java虚拟机实现可以为程序员或用户提供对方法区域的初始大小的控制，以及在变大小方法区域的情况下，控制最大和最小方法区域大小。

以下异常条件与方法区域相关联：

- 如果方法区域中的内存不能满足分配请求，则Java虚拟机会抛出`OutOfMemoryError`。



 **运行时常量池**:运行时常量池在每个类或者接口的class文件中代表 `constant_pool`表。 **它包含几种常量，从编译时已知的字面量到必须在运行时解析的方法和字段引用**。 运行时常量池提供类似于传统编程语言的符号表的功能，尽管它包含比典型符号表更宽范围的数据。

每个运行时常量池都是从Java虚拟机的方法区域分配的。 当Java虚拟机创建类或接口时，将构造类或接口的运行时常量池。

以下异常条件与类或接口的运行时常量池的构造相关联：

- 创建类或接口时，如果运行时常量池的构造需要的内存比Java虚拟机的方法区域中可用的内存多，则Java虚拟机会抛出`OutOfMemoryError`。

**本地方法栈**：Java虚拟机的实现可以使用传统的堆栈，俗称“C堆栈”，以支持native方法（用Java编程语言以外的语言编写的方法）。 native方法堆栈也可以通过以诸如C语言的语言为Java虚拟机的指令集实现解释器来使用。无法加载native方法并且本身不依赖于传统堆栈的Java虚拟机实现不需要提供本机方法栈。 如果提供，则通常在创建每个线程时为每个线程分配native方法堆栈。

此规范允许本机方法堆栈具有固定大小或根据计算的需要动态扩展和收缩。 如果本机方法堆栈具有固定大小，则可以在创建该堆栈时独立地选择每个本机方法堆栈的大小。

Java虚拟机实现可以为程序员或用户提供对本机方法堆栈的初始大小的控制，以及在不同大小的本机方法堆栈的情况下，控制最大和最小方法堆栈大小。

以下异常条件与本机方法堆栈相关联：

- 以下异常条件相关联如果线程中的计算需要比允许的更大的本机方法堆栈，则Java虚拟机会抛出`StackOverflowError`。

- 如果可以动态扩展native方法堆栈并尝试native方法栈扩展但可用内存不足，或者如果可用内存不足以为新线程创建初始本机方法堆栈，则Java虚拟机会抛出`OutOfMemoryError `。

------



## 栈帧

栈帧用于存储数据和部分结果，以及执行动态链接，返回方法的值以及调度异常。

每次调用方法时都会创建一个新帧。 当方法调用完成时，无论是正常完成或者抛出异常（它会抛出未捕获的异常），栈帧都将被销毁。 帧是从创建帧的线程的Java虚拟机堆栈分配的。 每个帧都有自己的局部变量数组，自己的操作数堆栈，以及对当前方法所在类的运行时常量池的引用。

可以使用附加的特定于实现的信息来扩展帧，例如调试信息。

局部变量数组和操作数堆栈的大小在编译时确定，并与用于与栈帧相关联的方法的代码一起提供。 因此，帧数据结构的大小仅取决于Java虚拟机的实现，并且可以在方法调用上同时分配这些结构的存储器。

只有一个帧（执行方法的帧）在给定控制线程中的任何点处都是活动的。 该帧被称为当前帧，并且其方法被称为当前方法。 定义当前方法的类是当前类。 局部变量和操作数堆栈的操作通常参考当前帧。

如果栈帧的方法调用另一个方法或其方法完成，则此栈帧将不再是当前栈帧。 调用方法时，会创建一个新帧，并在控制转移到新方法时成为当前帧。 在方法返回时，当前帧将其方法调用的结果（如果有）传递回前一帧。 然后当前一帧变为当前帧时丢弃当前帧。

请注意，由线程创建的帧是线程私有的，并且不能被任何其他线程引用。

**本地变量表**：每个帧包含一个称为局部变量的变量数组。 帧的局部变量数组的长度在编译时确定，并以类或接口的二进制表示形式提供，同时提供与帧相关的方法的代码。

单个局部变量可以包含boolean，byte，char，short，int，float，reference或returnAddress类型的值。 一对局部变量可以包含long或double类型的值。

通过索引来确定局部变量的位置。 第一个局部变量的索引为零。 索引的大小介于0和局部变量数组长度 - 1之间。

long类型或double类型的值占用两个连续的局部变量。 只能使用较小的索引来处理这样的值。 例如，存储在索引 n 的局部变量数组中的double类型实际上占用索引为n和n + 1的局部变量; 但是，索引n + 1的局部变量无法加载，它可以存储到。只能通过索引 n 获取。

Java虚拟机不要求n是偶数。 直观地说，long和double类型的值不需要在局部变量数组中进行64位对齐。 实现者可以使用为该值保留的两个局部变量自由决定表示此类值的适当方式。

Java虚拟机使用局部变量在方法调用上传递参数。 在类方法（static方法）调用中，任何参数都是从局部变量0开始的连续局部变量中传递的。在实例方法调用中，局部变量0总是用于传递对调用实例方法的对象的引用（在Java）。 随后，任何参数都在从局部变量1开始的连续局部变量中传递。

**操作数栈**：每个栈帧里包含一个后进先出（LIFO）堆栈，称为其操作数堆栈。 栈帧的操作数栈的最大深度在编译时确定，并与用于与栈帧相关联的方法的代码一起提供。

在上下文清晰的地方，我们有时会将当前帧的操作数堆栈称为操作数堆栈。

当创建包含操作数栈的帧时，操作数堆栈为空。 Java虚拟机提供指令以将局部变量或字段中的常量或值加载到操作数堆栈上。 其他Java虚拟机指令从操作数堆栈获取操作数，对它们进行操作，并将结果推回操作数堆栈。 操作数堆栈还用于准备要传递给方法和接收方法结果的参数。

例如，`iadd`指令将两个int值一起添加。 它要求要添加的int值是操作数堆栈的前两个值，由前面的指令推送到那里。 两个int值都从操作数堆栈中弹出。 它们相加后的总和被推回到操作数堆栈上。 子计算可以嵌套在操作数堆栈上，从而产生可以由包含计算使用的值。

操作数堆栈上的每个条目都可以包含任何Java虚拟机类型的值，包括long类型或double类型的值。

必须以适合其类型的方式操作操作数堆栈中的值。 例如，不可能推送两个int值，然后将它们视为long或推送两个float值，然后使用`iadd`指令添加它们。 少量Java虚拟机指令（dup指令和交换）作为原始值在运行时数据区域上运行，而不考虑它们的特定类型; 这些指令的定义方式使它们不能用于修改或分解单个值。 操作数堆栈操作的这些限制是通过类文件验证强制执行的。

在任何时间点，操作数堆栈都具有相关联的深度，其中long或double类型的值对深度贡献两个单位，而任何其他类型的值贡献一个单位。

**动态链接**：每个栈帧包含对运行时常量池（Run-Time Constant Pool）的引用，用于支持对当前方法的类型的方法代码的动态链接的。

方法的 class 文件代码是指要调用的方法和要通过符号引用访问的变量。 动态链接将这些符号方法引用转换为具体的方法引用，根据需要加载类以解析尚未定义的符号，并将变量访问转换为与这些变量的运行时位置相关联的存储结构中的适当偏移。

方法和变量的这种后期绑定使得方法使用的其他类中的更改不太可能破坏此代码。

**正常情况下完成方法调用**：如果调用不会直接从Java虚拟机或执行显式throw语句引发异常，则方法调用会正常完成。 如果当前方法的调用正常完成，则可以将值返回给调用方法。 当被调用的方法执行其中一个返回指令时，就会发生这种情况，返回指令的选择必须适合于返回值的类型（如果有的话）。

在这种情况下，当前帧用于恢复调用者的状态，包括其局部变量和操作数堆栈，调用者的程序计数器适当地递增以跳过方法调用指令。 然后执行在调用方法的帧中正常继续，返回值（如果有）被推送到该帧的操作数堆栈。

 **发生异常的方法调用**：如果在方法中执行Java虚拟机指令导致Java虚拟机抛出异常，并且该异常未在该方法中处理，则方法调用突然完成。 执行athrow指令还会导致显式抛出异常，如果当前方法未捕获异常，则会导致突然的方法调用完成。 突然完成的方法调用永远不会向其调用者返回值。

**对象的表示**：Java虚拟机不要求对象的任何特定内部结构。

在Oracle的一些Java虚拟机实现中，对类实例的引用是指向句柄的指针，该句柄本身是一对指针：一个指向包含对象方法的表和一个指向表示Class对象的指针 对象的类型，另一个是从堆中为对象数据分配的内存。



## 特殊方法

------

**实例初始化方法**：

类具有零个或多个实例初始化方法，每个方法通常对应于用Java编程语言编写的构造函数。

- 如果满足以下所有条件，则方法是实例初始化方法：
- 它在类（不是接口）中定义。
- 它具有特殊名称<init>。
- 它是`void` 返回类型

在类中，任何名为<init>的非void方法都不是实例初始化方法。 在接口中，任何名为<init>的方法都不是实例初始化方法。 任何Java虚拟机指令都不能调用此类方法，并且格式检查会拒绝这些方法。

实例初始化方法的声明和使用受Java虚拟机的约束。 对于声明，方法的 access_flags 项和代码数组受到约束。 对于使用，实例初始化方法可以仅由未初始化的类实例上的invokespecial指令调用。

因为名称<init>不是Java编程语言中的有效标识符，所以它不能直接用在用Java编程语言编写的程序中。

类初始化方法：类或接口最多只有一个类或接口初始化方法，并由调用该方法的Java虚拟机初始化。

如果满足以下所有条件，则方法是类或接口初始化方法：

- 它的特殊名称是<clinit>。
- 它是`void` 返回类型
- 在版本号为51.0或更高的类文件中，该方法设置了ACC_STATIC标志并且不带参数

在Java SE 7中引入了对 ACC_STATIC 的要求，并且在Java SE 9中没有引用参数。在版本号为50.0或更低的类文件中，名为<clinit>的void 方法被认为是类或接口初始化方法 无论其ACC_STATIC标志的设置或是否需要参数。

类文件中名为<clinit>的其他方法不是类或接口初始化方法。 它们永远不会被Java虚拟机本身调用，不能被任何Java虚拟机指令调用，并且会被格式检查拒绝。

因为名称<clinit>不是Java编程语言中的有效标识符，所以它不能直接用在用Java编程语言编写的程序中。

**签名多态方法**：如果满足以下所有条件，则方法是签名多态的：

- 它在java.lang.invoke.MethodHandle类或java.lang.invoke.VarHandle类中声明。
- 它有一个`Object [] `类型的形式参数。
- 它设置了ACC_VARARGS和ACC_NATIVE标志。

## 对象的创建

虚拟机遇到一条new命令时，首先将去检查这个指令的参数是否能在常量池中定位到一个符号引用，并且检查这个符号的引用代表的类是否已被加载、解析和初始化过。如果没有则必须执行相应的加载过程

