## 12.4。类和接口的初始化

类的*初始化*包括执行其静态初始化程序和`static`类中声明的字段（类变量）的初始化程序。

*初始化* 的接口由执行用于字段（常数）的初始化的接口中声明。

### 12.4.1。发生初始化时

类或接口类型T将在第一次出现以下任何一个之前立即初始化：

- T是一个类，并且创建了T的实例。
- 阿`static`通过声明的方法Ť被调用。
- 阿`static`通过声明字段Ť被分配。
- 使用`static`由T声明的字段，该字段不是常量变量（第[4.12.4节](https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.12.4)）。

初始化类时，初始化其超类（如果它们之前未初始化），以及声明任何默认方法（第[9.4.3节](https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html#jls-9.4.3)）的任何超接口（第[8.1.5 ](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.1.5)[节](https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html#jls-9.4.3)）（如果它们之前未初始化） ）。接口的初始化本身不会导致其任何超接口的初始化。

对`static`字段的引用（第[8.3.1.1节](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.3.1.1)）仅导致实际声明它的类或接口的初始化，即使它可能通过子类的名称，子接口或实现接口的类来引用。

在类`Class`和包中调用某些反射方法`java.lang.reflect`也会导致类或接口初始化。

在任何其他情况下，不会初始化类或接口。

请注意，编译器可能会 在接口中生成*合成*默认方法，即既未显式也未隐式声明的默认方法（第[13.1节](https://docs.oracle.com/javase/specs/jls/se11/html/jls-13.html#jls-13.1)）。尽管源代码没有给出应该初始化接口的指示，但是这样的方法将触发接口的初始化。

目的是类或接口类型具有一组初始化器，使其处于一致状态，并且该状态是其他类观察到的第一个状态。静态初始值设定项和类变量初始值设定项以文本顺序执行，并且可能不引用在声明在使用后以文本方式出现的类中声明的类变量，即使这些类变量在范围内（第[8.3.3节](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.3.3)）。此限制旨在在编译时检测大多数循环或其他格式错误的初始化。

初始化代码不受限制的事实允许构造示例，其中在其初始化表达式被评估之前，当它仍然具有其初始默认值时可以观察到类变量的值，但是这样的示例在实践中是罕见的。（这些示例也可以构造为例如变量初始化（第[12.5节](https://docs.oracle.com/javase/specs/jls/se11/html/jls-12.html#jls-12.5)）。）这些初始化器中提供了Java编程语言的全部功能。程序员必须小心谨慎。这种能力给代码生成器带来了额外的负担，但是在任何情况下都会产生这种负担，因为Java编程语言是并发的（[§12.4.2](https://docs.oracle.com/javase/specs/jls/se11/html/jls-12.html#jls-12.4.2)).

## 自动内存管理机制

运行时数据区：Java虚拟机定义了在程序执行期间使用的各种运行时数据区域。 其中一些数据区域是在Java虚拟机启动时创建的，仅在Java虚拟机退出时销毁。 其他数据区域是每个线程所占的空间。 线程数据区域是随着线程销毁和创建的。

**The `pc` Register**：Java虚拟机可以同时支持许多执行线程。 每个Java虚拟机线程都有自己的pc（程序计数器）寄存器。 在任何时候，每个Java虚拟机线程都在执行单个方法的代码，即该线程的当前方法（第2.6节）。 如果该方法不是native方法，则pc寄存器包含当前正在执行的Java虚拟机指令的地址。 如果线程当前正在执行的方法是native的，则Java虚拟机的pc寄存器的值是未定义的。 Java虚拟机的pc寄存器足够宽，可以在特定平台上保存returnAddress或native 指针。

 **Java Virtual Machine Stacks**：每个Java虚拟机线程都有一个私有Java虚拟机栈，与线程同时创建。 Java虚拟机栈存储帧。 Java虚拟机栈类似于传统语言的栈，例如C：它保**存局部变量和部分结果，并在方法调用和返回中起作用**。 由于除了压入和弹出帧之外，永远不会直接操作Java虚拟机栈，而帧可以是堆分配的。所以 Java虚拟机栈的内存不需要是连续的。

在Java®虚拟机规范的第一版中，Java虚拟机栈被和Java栈是一个意思。

此规范允许Java虚拟机栈具有固定大小或根据计算的需要动态扩展和收缩。 如果Java虚拟机堆栈具有固定大小，则可以在创建该栈时独立选择每个Java虚拟机堆栈的大小。

Java虚拟机实现可以为程序员或用户提供对Java虚拟机栈的初始大小的控制，以及在动态扩展或收缩Java虚拟机堆栈的情况下，控制最大和最小大小。

以下异常条件与Java虚拟机堆栈相关联：

- 如果线程中的计算需要比允许的更大的Java虚拟机堆栈，则Java虚拟机会抛出`StackOverflowError`.
- 如果可以动态扩展Java虚拟机堆栈，并且尝试进行扩展但可以使用的内存不足以实现扩展，或者可以使用的内存不足以为新线程创建初始Java虚拟机堆栈，则可以使用Java虚拟机抛出`OutOfMemoryError`.

**Heap**：Java虚拟机有一个在所有Java虚拟机线程之间共享的堆。堆是运行时数据区，**从中分配所有类实例和数组的内存**。

堆是在虚拟机启动时创建的。存储在堆上的对象由自动存储管理系统（称为垃圾收集器）回收 ; 对象永远不会被用户显式释放。 Java虚拟机假设没有特定类型的自动存储管理系统，可以根据实现者的系统要求选择存储管理技术。堆可以是固定大小的，或者可以根据计算的需要进行扩展，如果不需要更大的堆，则可以收缩。**堆的内存不需要是连续的。**

Java虚拟机实现可以为程序员或用户提供对堆的初始大小的控制，以及如果可以动态扩展或收缩堆，则控制最大和最小堆大小。

以下异常情况与堆相关联：

- 如果计算需要的堆的大小超过自动存储管理系统可用的堆，则Java虚拟机会抛出`OutOfMemoryError`。

**Method Area**：Java虚拟机具有在所有Java虚拟机线程之间共享的方法区域。 方法区域类似于传统语言的编译代码的存储区域或类似于操作系统进程中的“文本”段。 它存储每个类的结构，例如**运行时常量池，字段和方法数据，以及方法和构造函数的代码，包括类和接口初始化以及实例初始化中使用的特殊方法**

方法区域是在虚拟机启动时创建的。 虽然方法区域在逻辑上是堆的一部分，但是简单的虚拟机实现可能选择不进行垃圾收集或压缩它。 此规范不强制方法区域的位置或用于管理编译代码的策略。 方法区域可以是固定大小的，或者可以根据计算的需要进行扩展，并且如果不需要更大的方法区域，则可以缩小方法区域。 方法区域的内存不需要是连续的。

Java虚拟机实现可以为程序员或用户提供对方法区域的初始大小的控制，以及在变大小方法区域的情况下，控制最大和最小方法区域大小。

以下异常条件与方法区域相关联：

- 如果方法区域中的内存不能满足分配请求，则Java虚拟机会抛出`OutOfMemoryError`。



 **Run-Time Constant Pool**:运行时常量池在每个类或者接口的class文件中代表 `constant_pool`表。 **它包含几种常量，从编译时已知的字面量到必须在运行时解析的方法和字段引用**。 运行时常量池提供类似于传统编程语言的符号表的功能，尽管它包含比典型符号表更宽范围的数据。

每个运行时常量池都是从Java虚拟机的方法区域分配的。 当Java虚拟机创建类或接口时，将构造类或接口的运行时常量池。

以下异常条件与类或接口的运行时常量池的构造相关联：

- 创建类或接口时，如果运行时常量池的构造需要的内存比Java虚拟机的方法区域中可用的内存多，则Java虚拟机会抛出`OutOfMemoryError`。

**Native Method Stacks**：Java虚拟机的实现可以使用传统的堆栈，俗称“C堆栈”，以支持native方法（用Java编程语言以外的语言编写的方法）。 native方法堆栈也可以通过以诸如C语言的语言为Java虚拟机的指令集实现解释器来使用。无法加载native方法并且本身不依赖于传统堆栈的Java虚拟机实现不需要提供本机方法栈。 如果提供，则通常在创建每个线程时为每个线程分配native方法堆栈。

此规范允许本机方法堆栈具有固定大小或根据计算的需要动态扩展和收缩。 如果本机方法堆栈具有固定大小，则可以在创建该堆栈时独立地选择每个本机方法堆栈的大小。

Java虚拟机实现可以为程序员或用户提供对本机方法堆栈的初始大小的控制，以及在不同大小的本机方法堆栈的情况下，控制最大和最小方法堆栈大小。

以下异常条件与本机方法堆栈相关联：

- 以下异常条件相关联如果线程中的计算需要比允许的更大的本机方法堆栈，则Java虚拟机会抛出`StackOverflowError`。

- 如果可以动态扩展native方法堆栈并尝试native方法栈扩展但可用内存不足，或者如果可用内存不足以为新线程创建初始本机方法堆栈，则Java虚拟机会抛出`OutOfMemoryError `。

------



## Frames

栈帧用于存储数据和部分结果，以及执行动态链接，返回方法的值以及调度异常。

每次调用方法时都会创建一个新帧。 当方法调用完成时，无论是正常完成或者抛出异常（它会抛出未捕获的异常），栈帧都将被销毁。 帧是从创建帧的线程的Java虚拟机堆栈分配的。 每个帧都有自己的局部变量数组，自己的操作数堆栈，以及对当前方法所在类的运行时常量池的引用。

可以使用附加的特定于实现的信息来扩展帧，例如调试信息。

局部变量数组和操作数堆栈的大小在编译时确定，并与用于与栈帧相关联的方法的代码一起提供。 因此，帧数据结构的大小仅取决于Java虚拟机的实现，并且可以在方法调用上同时分配这些结构的存储器。

只有一个帧（执行方法的帧）在给定控制线程中的任何点处都是活动的。 该帧被称为当前帧，并且其方法被称为当前方法。 定义当前方法的类是当前类。 局部变量和操作数堆栈的操作通常参考当前帧。

如果栈帧的方法调用另一个方法或其方法完成，则此栈帧将不再是当前栈帧。 调用方法时，会创建一个新帧，并在控制转移到新方法时成为当前帧。 在方法返回时，当前帧将其方法调用的结果（如果有）传递回前一帧。 然后当前一帧变为当前帧时丢弃当前帧。

请注意，由线程创建的帧是线程私有的，并且不能被任何其他线程引用。

**Local Variables**：每个帧包含一个称为局部变量的变量数组。 帧的局部变量数组的长度在编译时确定，并以类或接口的二进制表示形式提供，同时提供与帧相关的方法的代码。

单个局部变量可以包含boolean，byte，char，short，int，float，reference或returnAddress类型的值。 一对局部变量可以包含long或double类型的值。

通过索引来确定局部变量的位置。 第一个局部变量的索引为零。 索引的大小介于0和局部变量数组长度 - 1之间。

long类型或double类型的值占用两个连续的局部变量。 只能使用较小的索引来处理这样的值。 例如，存储在索引 n 的局部变量数组中的double类型实际上占用索引为n和n + 1的局部变量; 但是，索引n + 1的局部变量无法加载，它可以存储到。只能通过索引 n 获取。

Java虚拟机不要求n是偶数。 直观地说，long和double类型的值不需要在局部变量数组中进行64位对齐。 实现者可以使用为该值保留的两个局部变量自由决定表示此类值的适当方式。

Java虚拟机使用局部变量在方法调用上传递参数。 在类方法（static方法）调用中，任何参数都是从局部变量0开始的连续局部变量中传递的。在实例方法调用中，局部变量0总是用于传递对调用实例方法的对象的引用（在Java）。 随后，任何参数都在从局部变量1开始的连续局部变量中传递。

**Operand Stacks**：每个栈帧里包含一个后进先出（LIFO）堆栈，称为其操作数堆栈。 栈帧的操作数栈的最大深度在编译时确定，并与用于与栈帧相关联的方法的代码一起提供。

在上下文清晰的地方，我们有时会将当前帧的操作数堆栈称为操作数堆栈。

当创建包含操作数栈的帧时，操作数堆栈为空。 Java虚拟机提供指令以将局部变量或字段中的常量或值加载到操作数堆栈上。 其他Java虚拟机指令从操作数堆栈获取操作数，对它们进行操作，并将结果推回操作数堆栈。 操作数堆栈还用于准备要传递给方法和接收方法结果的参数。

例如，`iadd`指令将两个int值一起添加。 它要求要添加的int值是操作数堆栈的前两个值，由前面的指令推送到那里。 两个int值都从操作数堆栈中弹出。 它们相加后的总和被推回到操作数堆栈上。 子计算可以嵌套在操作数堆栈上，从而产生可以由包含计算使用的值。

操作数堆栈上的每个条目都可以包含任何Java虚拟机类型的值，包括long类型或double类型的值。

必须以适合其类型的方式操作操作数堆栈中的值。 例如，不可能推送两个int值，然后将它们视为long或推送两个float值，然后使用`iadd`指令添加它们。 少量Java虚拟机指令（dup指令和交换）作为原始值在运行时数据区域上运行，而不考虑它们的特定类型; 这些指令的定义方式使它们不能用于修改或分解单个值。 操作数堆栈操作的这些限制是通过类文件验证强制执行的。

在任何时间点，操作数堆栈都具有相关联的深度，其中long或double类型的值对深度贡献两个单位，而任何其他类型的值贡献一个单位。

**Dynamic Linking**：每个栈帧包含对运行时常量池（Run-Time Constant Pool）的引用，用于支持方法代码的动态链接的当前方法的类型。 每个帧包含对运行时常量池的引用，以对于当前方法的类型来说支持方法代码的动态链接。

方法的 class 文件代码是指要调用的方法和要通过符号引用访问的变量。 动态链接将这些符号方法引用转换为具体的方法引用，根据需要加载类以解析尚未定义的符号，并将变量访问转换为与这些变量的运行时位置相关联的存储结构中的适当偏移。

方法和变量的这种后期绑定使得方法使用的其他类中的更改不太可能破坏此代码。

**Normal Method Invocation Completion**：如果调用不会直接从Java虚拟机或执行显式throw语句引发异常，则方法调用会正常完成。 如果当前方法的调用正常完成，则可以将值返回给调用方法。 当被调用的方法执行其中一个返回指令时，就会发生这种情况，返回指令的选择必须适合于返回值的类型（如果有的话）。

在这种情况下，当前帧用于恢复调用者的状态，包括其局部变量和操作数堆栈，调用者的程序计数器适当地递增以跳过方法调用指令。 然后执行在调用方法的帧中正常继续，返回值（如果有）被推送到该帧的操作数堆栈。

 **Abrupt Method Invocation Completion**：如果在方法中执行Java虚拟机指令导致Java虚拟机抛出异常，并且该异常未在该方法中处理，则方法调用突然完成。 执行athrow指令还会导致显式抛出异常，如果当前方法未捕获异常，则会导致突然的方法调用完成。 突然完成的方法调用永远不会向其调用者返回值。

**Representation of Objects**：Java虚拟机不要求对象的任何特定内部结构。

在Oracle的一些Java虚拟机实现中，对类实例的引用是指向句柄的指针，该句柄本身是一对指针：一个指向包含对象方法的表和一个指向表示Class对象的指针 对象的类型，另一个是从堆中为对象数据分配的内存。



## 特殊方法

------

**实例初始化方法**：

类具有零个或多个实例初始化方法，每个方法通常对应于用Java编程语言编写的构造函数。

- 如果满足以下所有条件，则方法是实例初始化方法：
- 它在类（不是接口）中定义。
- 它具有特殊名称<init>。
- 它是`void` 返回类型

在类中，任何名为<init>的非void方法都不是实例初始化方法。 在接口中，任何名为<init>的方法都不是实例初始化方法。 任何Java虚拟机指令都不能调用此类方法，并且格式检查会拒绝这些方法。

实例初始化方法的声明和使用受Java虚拟机的约束。 对于声明，方法的 access_flags 项和代码数组受到约束。 对于使用，实例初始化方法可以仅由未初始化的类实例上的invokespecial指令调用。

因为名称<init>不是Java编程语言中的有效标识符，所以它不能直接用在用Java编程语言编写的程序中。

类初始化方法：类或接口最多只有一个类或接口初始化方法，并由调用该方法的Java虚拟机初始化。

如果满足以下所有条件，则方法是类或接口初始化方法：

- 它的特殊名称是<clinit>。
- 它是`void` 返回类型
- 在版本号为51.0或更高的类文件中，该方法设置了ACC_STATIC标志并且不带参数

在Java SE 7中引入了对 ACC_STATIC 的要求，并且在Java SE 9中没有引用参数。在版本号为50.0或更低的类文件中，名为<clinit>的void 方法被认为是类或接口初始化方法 无论其ACC_STATIC标志的设置或是否需要参数。

类文件中名为<clinit>的其他方法不是类或接口初始化方法。 它们永远不会被Java虚拟机本身调用，不能被任何Java虚拟机指令调用，并且会被格式检查拒绝。

因为名称<clinit>不是Java编程语言中的有效标识符，所以它不能直接用在用Java编程语言编写的程序中。

**签名多态方法**：如果满足以下所有条件，则方法是签名多态的：

- 它在java.lang.invoke.MethodHandle类或java.lang.invoke.VarHandle类中声明。
- 它有一个`Object [] `类型的形式参数。
- 它设置了ACC_VARARGS和ACC_NATIVE标志。





