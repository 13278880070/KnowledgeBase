## 判断对象是否存活的算法

主流商用语言的主流实现中，都是通过可达性分析来判定对象是否存活的。这个算法的基本思路就是通过一系列的成为"GC Roots"的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径成为引用链，当一个对象到 GC Roots 没有任何引用链相连（用图论的话说就是从GC Roots 到这个对象不可达）时，则证明此对象是不可用的。

在 java语言中，可作为GC Roots的对象包括下面几种：

- 虚拟机栈（栈帧中的本地变量表）中引用的对象。
- 方法区中静态属性引用的对象
- 方法区中常量引用的对象.
- 本地方法栈中JNI(即一般说的 native 方法) 引用的对象。



## 几种引用

### 可达性

从最强到最弱，不同的可达性水平反映了物体的生命周期。 它们在操作上定义如下：

- 如果某个对象可以在不遍历任何引用对象的情况下到达某个对象，则该对象是强可访问的。 新创建的对象相在创建它的线程上下文中是强可达的。

- 如果一个对象不是强可达的但是可以通过软引用达到那么这个对象是软可达的。
- 如果一个对象既不是强可达也不是软可达，但是可以通过弱引用达到，那么这个对象是弱可达的。 当清除对弱可达对象的弱引用时，该对象就有资格进行终结。
- 如果一个对象既没有强可达，软可达，也没有弱可达，那么该对象是幻像可达的，它已经被终结，并且一些幻像引用指向它。
- 最后，如果无法通过上述任何方式访问对象，则无法访问该对象，因此有资格进行回收。

在 JDK 1.2 之前，java中引用的定义很传统：如果reference 类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表一个引用。在1.2之后，java对引用的概念进行了扩充，将引用分为强引用（Atrong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference） 4 种，这 4 种引用强度依次减弱。

- **强引用**就是指在程序代码中普遍存在的，可以在线程上下文中直接获取到的对象的引用。

- **软引用**，由垃圾收集器根据内存需求自行决定清除。软引用通常用于实现对内存敏感的缓存。

  假设垃圾收集器在某个时间点确定对象是软可达的。此时，它可以选择原子地清除对该对象的所有软引用以及对通过一系列强引用可从该对象到达的任何其他可轻松访问的对象的所有软引用。在同一时间或稍后，垃圾回收器将已经回收的软引用对象的引用入队到引用队列中，以便将代表软引用对象的引用手动清除。

  在虚拟机抛出`OutOfMemoryError`之前，垃圾收集器保证已清除对软引用对象的所有软引用。否则，不会对清除软引用的时间或清除对不同对象的一组此类引用的顺序施加约束。但是，鼓励虚拟机实现偏向清除最近创建或最近使用的软引用。

  此类的直接实例可用于实现简单缓存;此类或派生的子类也可用于更大的数据结构，以实现更复杂的高速缓存。只要软引用的引用是强可达的，即实际上是在使用中，软引用就不会被清除。因此，复杂的高速缓存可以例如通过保持对这些条目的强烈指示来防止其最近使用的条目被丢弃，留下剩余的条目由垃圾收集器决定丢弃。

* **弱引用**，它们不会阻止它们的指向对象可被最终结（只要进行垃圾回收就将弱引用回收），终结，然后回收。 弱引用最常用于实现规范化映射。
  假设垃圾收集器在某个时间点确定对象是弱可达的。 然后，他会原子地清除该对象上所有的若引用，并且通过一个强引用和软引用的引用链来清除所有可达的若引用。 同时，它将声明所有以前弱可达的对象可以被终结。 在同一时间或稍后，它将使用引用队列注册的新清除的弱引用入队。

* **幻像引用**，在垃圾收集器确定幻像引用对象可以被回收如后，将他们压入引用队列。 幻影引用通常用于安排事后清理操作。
  假设垃圾收集器在某个时间点确定对象是幻像可达的。 那时它将原子地清除对该对象的所有幻像引用以及对该对象可从其访问的任何其他可进入幻像的对象的所有幻像引用。 在同一时间或稍后，它将使用参考队列注册的新清除的幻像引用入队。

  为了确保可回收对象保持不变，可能无法检索幻像引用的引用：幻像引用的get方法始终返回null，也就是说无法获取幻想引用的实例。

  为一个对象设置一个幻像引用关联的唯一目的就是能在这个对象被垃圾收集器回收时收到了一个系统通知。

### 对象死亡过程

1. 当分配对象时，JVM内部会记录这个对象是当分配对象时，JVM内部会记录这个对象是finalizable（可被终结的）
2. 当垃圾回收器在进行可达性分析后发现一个对象是不可达的，并且发现这个对象是 finalizable（当分配对象时已经被记录）。则垃圾回收器将把这个对象加入到一个 finalization queue 中。它还确保保留从该对象可到达的所有其他对象，即使它们无法访问，因为它们可能被终结器访问。 图2说明了Image1的一个实例。
3. 稍后，JVM的 finalizer 线程会将该对象排出队列，并调用该对象的 `finalize()`方法，同时记录该对象的finalizer方法已经被调用，这是obj可以认为是finalized（已经被终结）。
4. 当垃圾收集器重新发现该对象是不可达的，收集器会回收该对象和所有从该对象可达的对象(此时该对象无法通过其他方式可达)。

如果想让一个对象在此期间逃脱死亡的机会，则需要在此期间将该对象与引用链上的对象关联。

## 垃圾收集算法

### 标记—清除算法：

算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后同一回收所有被标记的对象。

不足：一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记-清除过程后会产生大量的不连续的内存碎片，内存碎片太多可能会导致以后再程序运行过程中需要分配较大的对象时，无法找到足够的连续内存而不得不提前出发下一次垃圾收集动作。

### 复制算法：

复制算法将内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次对整个半区进行内存回收，内存分配时就不用考虑内存碎片等复杂情况，只要移动指针，按顺序分配内存即可。

不足：将可用内存缩小为原来的一半，代价过高。

### 标记-整理算法：

过程与标记-清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理到端边界以外的内存。

### 分代收集算法：

当前商业虚拟机都是用“分代收集算法”进行垃圾收集。这种算法根据对象生存周期的不同把java 堆分为新生代和老年代。新生带的对象生存周期短每次垃圾收集后都有大量的对象死去，只有少部分的对象存活，适用于复制算法。虚拟机将新生带分为一块较大的Eden 空间，和两块较小的 Survivor 空间。Eden 空间和 Survivor 空间默认的大小比例为 8：1 。每次垃圾收集时，都将Eden 空间和 一块 Survivor 空间上的存活对对象复制到另外一块 Survivor空间上，每次适用的空间站新生代的 90 % 。但Survivor的空间不够时，需要依赖老年代进行分配担保。



