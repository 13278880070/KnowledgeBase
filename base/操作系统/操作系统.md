### 进程和线程的区别

### 进程

进程最根本的属性是动态性和并发性。我们将进程定义为**程序在并发环境中的执行过程**，**进程是资源分配个调度的基本单位。**

作为资源分配的单位，一个进程有自己的地址空间，其中包括程序，数据、PCB及其他资源。作为调度执行的单位，一个进程在执行的过程中需要使用一个或多个程序；另外一个进程的执行过程会与其他进程夹在一起。操作系统根据进程的状态和调度优先级对就绪进程实施调度。

**进程**和**程序**又密切的关系，但有时两个完全不同的概念，他们在以下四个方面有重要区别：

1. 动态性

   程序是静态被动的概念，本身可以作为一种软件资源长期保存：而进程是程序的一次执行过程，是动态、主动的概念，有一定的生命期，会动态地产生和消亡。

2. 并发性

   传统进程是一个独立运行的单位，能与其他进程并发执行。进程是作为资源申请和调度单位存在的；而通常的程序是不能作为一个独立运行的单位而并发执行的。

3. 非对应性

   程序和进程无一一对应关系，一个程序可以被多个进程公用：一个进程再起活动中又可顺序地执行若干程序。

### 进程的同步和通信

由于进程具有动态性和并发性。由于各个进程对资源的共享以及为完成一项共同的任务需要彼此合作。变产生了相互制约的关系。如果不加约束就会产生混乱。所以进程在并发环境中是不安全的，需要有同步机制来保持进程的正常活动。

进程间的相互关系主要分为如下三种形式：

1. **互斥**：各个进程彼此不知道对方存在，逻辑上没有关系。由于竞争同一资源而彼此发生制约。

   实现机制：硬件解决办法：禁止中断、专用机器指令

   ​		软件解决办法：使用算法

2. **同步**：各个进程不知道对方的名字，但通过某些对象（如I/O 缓冲区）的共同存取来协同完成任务。

   同步工具：信号量：整形信号量、结构型信号量、二值信号量

3. **通信**：各个进程可以通过名字彼此之间直接进行通信，交换信息，合作完成一项工作。

   进程通信方式：共享存储器、消息传递（直接通信：将消息挂载接受进程的消息缓冲队列上，接受进程直接从缓冲队列中得到消息。间接通信：发送进程将消息发送到称为信箱的中间设施中，接受进程从信箱中读取消息）、管道文件方式：连接连个命令的一个打开文件。（linux 中的管道  `|`）


### 线程

线程是进程中实施调度和分派的进本单位。

引入线程的好处：

1. 易与调度
2. 提高并发性
3. 开销少
4. 利于充分发挥多核处理器的功能

### 线程和进程的关系

1. 一个进程可以有多个线程，但至少有一个线程；并且，一个线程只能在一个进程地址空间内活动。
2. 资源分配给进程，同一进程的所有线程共享该进程的所有资源。
3. 处理机分配给线程，即真正在处理机上运行的是线程。
4. 线程在执行过程中需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。

###### 死锁

死锁：在一个进程集合中每个进程都在等待仅由该集合中的另一个进程才能引发的事件（一般是释放资源）而无限期地僵持下去的过程。死锁产生的根本原因是资源有限且操作不当。

### 死锁的条件

1. #### 互斥条件

   某个资源在一段时间内只能由一个进程占有，不能同时被两个以上的进程占有。必须在占有该资源的进程主动释放它后，其他进程才能占有该资源。这是资源本身的属性所决定的。

2. #### 占有且等待条件

   进程已经占有一个资源，但又申请新的资源。由于该资源已被另外一个进程占有，此时该进程阻塞。但是他在等待新资源时，仍继续占有已分到的资源。

3. #### 不可抢占条件

   一个进程所占有的资源在用完之前，其他进程不能强行夺走该资源，只能由该进程用完后主动释放。

4. #### 循环等待条件

   存在一个进程等待序列，形成了一个环。

### 处理死锁的方法

原则上讲，处理死锁的方法有一下三种：

1. 利用某些协议预防或避免死锁，保证系统不会进入死锁状态。
2. 允许系统进入死锁状态，然后设法发现并解除它。
3. 完全忽略这个问题，好像系统中从来也不会出现死锁。

### 死锁的预防

* 破坏互斥条件

  一般来说，使用否定互斥条件的办法是不能预防死锁的，因为某些资源的固有属性就是不可共享的。

* 破坏占有且等待条件

  为使系统从来不会出现“占有且等待条件”，需要保证一个无论什么时候都可以申请它没有占用的任何资源。

  一种办法是**预分资源策略**，即在一个进程开始执行之前就申请并分配到所需的全部资源。在实现时，一个进程申请资源的系统调用要先于其他的系统调用。这就是资源的**静态分配**。

  另一种办法是**“空手”申请资源策略**，即每个进程仅在它不占有资源时才可以申请资源。一个进程可能需要申请并使用某些资源，在他们申请另外附加资源之前，必须先释放当前分配到的全部资源。

* 破坏不可抢占条件

  可以采用隐式抢占方式，如果一个进程占有某些资源，他还要申请被别的进程占有的资源，该进程就一定处于等待状态。这时，该进程当前所占有的全部资源可被抢占。也就是说这些资源隐式地释放了，在该进程的资源申请表中加上刚才隐式释放的资源。仅当进程获得他被剥夺的资源和新申请的资源时，他才能重新启动。

  另一种方法是抢占等待者的资源。若一个进程申请某些资源，首先应检查他们是否可供使用。如果可用，就分给该进程；如果他们不可用，就要查看：他们是否已分给另外某个正等待附加资源的进程。如果该资源被其他没有申请资源的进程占有，那么申请进程必须等待。当该进程等待时，它的某些资源也可被抢占过去。仅当一个进程分到它所需的新资源并恢复他在等待期间被强占过去的所有资源的情况下，他才能重新启动。

* 破坏循环等待条件

  为了不出现循环等待的条件，一种方法是实行**资源有序分配**策略，即把全部资源事先按类编号，然后依序分配，使进程申请、占用资源时不会形成环路。

### 死锁的避免

1. 银行家算法
2. 资源分配图算法
3. 安全状态：当一个进程申请一个可用资源时，系统必须决定：是把该资源立即分给它，还是让该进程等待，仅当系统处于安全状态下才能申请。

### 调度

调度算法：

1. 先来先服务法（FCFS）
2. 短作业优先法(SJF)
3. 最短剩余时间优先法(SRTF)
4. 优先级法()
5. 轮转法(RR)
6. 多级队列法()
7. 多级反馈队列法(MFQ)
8. 高响应比优先法(HRRF)  响应比RR=w+s/s (w:进程等待处理机所用时间 s:进程要求服务的时间)
9. 公平共享法



### 存储管理

#### 页面置换算法

1. 先进先出法
2. 最佳置换法
3. 最近最少使用法
4. 第二次机会置换法
5. 时钟置换法
6. 最少使用置换法
7. 页面缓冲算法



### 

