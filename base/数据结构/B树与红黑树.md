## B树

B 树**可以看作是对2-3查找树的一种扩展，即他允许每个节点有M-1个子节点。

- 根节点至少有两个子节点
- 每个节点有M-1个key，并且以升序排列
- 位于M-1和M key的子节点的值位于M-1 和M key对应的Value之间
- 其它节点至少有M/2个子节点

**B+**树是对B树的一种变形树，它与B树的差异在于：

- 有k个子结点的结点必然有k个关键码；
- 非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中。
- 树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录。

B+ 树的优点在于：

- 由于B+树在内部节点上不包含数据信息，因此在内存页中能够存放更多的key。 数据存放的更加紧密，具有更好的空间局部性。因此访问叶子节点上关联的数据也具有更好的缓存命中率。
- B+树的叶子结点都是相连的，因此对整棵树的便利只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。

**数据库为什么使用B 数来作为索引结构呢?**

文件系统和数据库的索引都是存在磁盘上的，如果数据量大的话不能一次性加载到内存当中，使用B 树，就可以发挥B 树的多路存储的特性，每次只加载B 树的一个节点，一步步往下找。如果在内存中，红黑树的效率比B 数更高，但是涉及到磁盘操作，B 数就更优了。

而且像MySQL 数据库的B 树索引都是B + 树。设计到多条操作的时候可以避免B 树的跨层访问。而B + 树的数据都在叶子节点，不用跨层，同时由于有链表结构，只需找到首尾，通过链表就能把数据都找出来。

**Hash 索引比 B 树更快，为什么MySQL 还用B 树来索引呢？**

和业务场景有关，如果只选一个数据，Hash 索引更快，如果数据库中经常会选择多条，这时候由于B+树索引有序且叶子节点为链表，它的查询效率就比Hash 快很多了。而且数据库中出的索引一般是在磁盘上，数据量大的情况无法一次装入内存，B+ 树 可以允许数据分批加载，同时树的高度较低，提高查找效率。



## 红黑树

### 基本特征：

1. 节点不是红色就是黑色
2. 根节点和叶子节点是黑色（叶子节点为 NIL或者空节点）
3. 红色节点的子节点必须是黑色节点
4. 从任意节点到其叶子节点的黑色节点数相等。

在 java 的集合类中，为什么使用红黑树？

红黑树是平衡数的一种，普通的二叉搜索树在极端条件下会退化成链表，而红黑树可以保证最短子树的长度至少是最长子树的一半。在树因为调整的性能损耗与因为退化造成的性能损耗之间达到一个平衡。

