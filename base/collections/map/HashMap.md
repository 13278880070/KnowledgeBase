## HashMap ##

```java
public class HashMap<K,V> extends AbstractMap<K,V>
    implements Map<K,V>, Cloneable, Serializable 
```

### java doc ###

基于哈希表的Map接口实现。此实现提供所有可选的映射操作，并允许空值和空键。 （HashMap类大致相当于Hashtable，除了它是不同步的并且允许空值。）这个类不保证Map的顺序;特别是，它不保证订单会随着时间的推移保持不变。
假设散列函数在桶之间正确地分散元素，该实现为基本操作（get和put）提供了恒定时间性能。对集合视图的迭代需要与HashMap实例的“容量”（桶的数量）加上其大小（键 - 值映射的数量）成比例的时间。因此，如果迭代性能很重要，则不要将初始容量设置得太高（或负载因子太低）非常重要。

HashMap的一个实例有两个影响其性能的参数：初始容量和负载因子。容量是哈希表中的桶数，初始容量只是创建哈希表时的容量。加载因子是在自动增加容量之前允许哈希表获取的完整程度的度量。当哈希表中的条目数超过加载因子和当前容量的乘积时，哈希表将被重新哈希（即，重建内部数据结构），以便哈希表具有大约两倍的桶数。

作为一般规则，默认加载因子（.75）在时间和空间成本之间提供了良好的折衷。较高的值会减少空间开销，但会增加查找成本（反映在HashMap类的大多数操作中，包括get和put）。在设置其初始容量时，应考虑映射中的预期条目数及其负载因子，以便最小化重新散列操作的数量。如果初始容量大于最大条目数除以加载因子，则不会发生重新加载操作。

如果要将多个映射存储在HashMap实例中，则使用足够大的容量创建映射将允许映射更有效地存储，而不是根据需要执行自动重新散列来扩展表。请注意，使用具有相同`hashCode()`的许多键可以使任何哈希表的性能下降。为了改善影响，当键是可比较时，该类可以使用键之间的比较顺序来帮助打破关系。

请注意，此实现不同步。如果多个线程同时访问哈希映射，并且至少有一个线程在结构上修改了映射，则必须在外部进行同步。 （结构修改是添加或删除一个或多个映射的任何操作;仅更改与实例已包含的键相关联的值不是结构修改。）这通常通过同步自然封装映射的某个对象来完成。 。如果不存在此类对象，则应使用Collections.synchronizedMap方法“包装”该映射。这最好在创建时完成，以防止意外地不同步访问Map：

```java
  Map m = Collections.synchronizedMap(new HashMap(...));
```

所有这个类的“集合视图方法”返回的迭代器都是快速失败的：如果在创建迭代器之后的任何时候对映射进行结构修改，除了通过迭代器自己的remove方法之外，迭代器将抛出ConcurrentModificationException。。 因此，在并发修改的情况下，迭代器快速而干净地失败，而不是在未来的未确定时间冒任意，非确定性行为的风险。

请注意，迭代器的快速失败行为无法得到保证，因为一般来说，在存在不同步的并发修改时，不可能做出任何硬性保证。 失败快速迭代器会尽最大努力抛出`ConcurrentModificationException`。 因此，编写依赖于此异常的程序以确保其正确性是错误的：迭代器的快速失败行为应该仅用于检测错误。

### 字段 ### 

实施说明。

此map通常用作箱（bucketed）哈希表，但是
当bins变得太大时，bins转换成
TreeNodes，与java.util.TreeMap中的结构类似
。 大多数方法都尝试使用bins，但是
适用时中继到TreeNode方法（只需检查
节点的实例）。 TreeNodes的Bin可以像其他任何一样遍历和使用，但是当元素过多时还支持更快的查找。
但是，由于绝大多数的bins
正常使用不会充满满容量，检查 tree bins的存在可能会在table方法中延迟。
树容器（其元素都是TreeNodes的bin）
主要由hashCode排序，但在ties的情况下，如果两个
元素是相同的“C类实现Comparable <C>”，
然后使用他们的`compareTo`方法进行排序。 （我们
通过反射保守地检查泛型类型以进行验证
。 请参阅compareClassFor方法。 增加的复杂性
在提供最坏情况O（log n）时，tree bin 的价值是值得的。
当密钥具有不同的哈希值或可订购时，树箱的额外复杂性值得提供最坏情况的O（log n）操作，
，因此，在hashCode（）方法返回分布不佳的值的意外或恶意用法中，性能会优雅地降级，
返回分布不均的值以及中的值。
以及许多键共享hashCode的那些，只要它们也是可比较的。
 （如果这些都不适用，与不采取预防措施相比，我们可能在时间和空间上浪费大约两倍。 但是，唯一已知的案例源于糟糕的用户编程实践，这些实践已经非常缓慢，这几乎没有什么区别。）

因为TreeNodes大约是常规节点大小的两倍，所以我们
仅当 bins 包含足够的节点以保证使用时才使用它们
（见TREEIFY_THRESHOLD）。 当它们变得太小时（由于
移除或调整大小）它们被转换回普通箱。在具有良好分布的`hashCodes`的用法中，树箱是
很少用。 理想情况下，在随机hashCodes下，频率为
箱中的节点遵循泊松分布带有
默认大小调整的平均参数约为0.5
阈值为0.75，虽然因为有很大的差异
调整粒度。 忽略方差，预期
列表大小k的出现是

（exp（-0.5）pow（0.5，k）/ factorial（K））

 第一个值是：

0:    0.60653066<p>
1:    0.30326533<p>
2:    0.07581633<p>
3:    0.01263606<p>
4:    0.00157952<p>
5:    0.00015795<p>
6:    0.00001316<p>
7:    0.00000094<p>
8:    0.00000006<p>
更多情况：不到千万分之一

树bin的根通常是它的第一个节点。 然而，
有时（目前仅在Iterator.remove上），根可能
在其他地方，但可以在父链接后恢复
（方法`TreeNode.root()`）。

所有适用的内部方法都接受哈希码作为
参数（通常由公共方法提供），允许
他们互相调用而不重新计算`hashCodes`。
大多数内部方法也接受“tab”参数，这通常是当前table，但在调整大小或转换时可能是新的或旧的。

当bin列表被树化，拆分或未解析时，我们会保留
它们处于相同的相对访问/遍历顺序（即字段 Node.next）以更好地保留局部性，并略微保持局部性
简化对调用的拆分和遍历的处理
iterator.remove。 在插入时使用比较器时，要保持一个
总排序（或尽可能接近）
重新平衡，我们比较类和`identityHashCodes`为
搭配断路器。

他在普通与树模式之间使用和转换是
  复杂的子类LinkedHashMap的存在。 看到
下面是定义为在插入时调用的钩子方法，
删除和访问允许LinkedHashMap内部
否则保持独立于这些机制。 （这还要求将映射实例传递给可能创建新节点的一些实用程序方法。）

类似于并发编程的基于SSA的编码风格有助于避免在所有扭曲指针操作中出现混叠错误。



```
/**
 * 默认初始容量 - 必须是2的幂。
 */
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // 16
```

```
/**
 * 如果具有参数的任一构造函数隐式指定较高值，则使用最大容量。
 * 2 的次幂 <= 1<<30.
 */
static final int MAXIMUM_CAPACITY = 1 << 30;
```

```
/**
 * 在构造函数中未指定时使用的加载因子。
 */
static final float DEFAULT_LOAD_FACTOR = 0.75f;
```

```
/**
  *bin计数阈值，用于使用树而不是bin的列表. 
  *将元素添加到具有至少这么多节点的bin时，bin被转换为树。
  *该值必须大于2并且应该至少为8以与树木移除中的假设相关联，以便在收缩时转换   *回普通箱。
  */
static final int TREEIFY_THRESHOLD = 8;
```

```
/**
 * 用于在调整大小操作期间解除（拆分）bin的bin计数阈值。
 * 应小于TREEIFY_THRESHOLD，最多6个与去除时的收缩检测啮合。
 */
static final int UNTREEIFY_THRESHOLD = 6;
```

```
/**
 * 容器可以树化的最小表容量。
 *（否则，如果bin中的节点太多，则会调整表的大小。）
 *应该至少4 * TREEIFY_THRESHOLD以避免
 *调整大小和树化阈值之间关系的冲突。
 */
static final int MIN_TREEIFY_CAPACITY = 64;
```